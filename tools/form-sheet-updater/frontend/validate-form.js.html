<script>

function validateStructure(expected, actual, prefix) {
  var typeOfExpected = typeof expected;

  if (typeof actual === 'undefined') {
    return [{ field: prefix, expected: expected, actual: "undefined" }];
  }
  if (typeOfExpected !== "object") {
    if (expected !== actual) {
      return [{ field: prefix, expected: expected, actual: actual }];
    }
    return [];
  }

  if (Array.isArray(expected)) {
    if (expected.length != actual.length) {
      return [{ field: prefix + ".length", expected: expected.length, actual: actual.length }];
    }
  }

  const entries = Object.entries(expected)
  var errors = [];
  for (const [expectedFieldName, expectedFieldValue] of entries) {
    var errs = validateStructure(expectedFieldValue, actual[expectedFieldName], prefix + "." + expectedFieldName);
    errors.push(...errs)
  }

  return errors;
}

// from https://gist.github.com/renaudtertrais/25fc5a2e64fe5d0e86894094c6989e10
const zip = (arr, ...arrs) => {
  return arr.map((val, i) => arrs.reduce((a, arr) => [...a, arr[i]], [val]));
}

function detectMismatches(desired, actual, fieldName) {
  const d = desired[fieldName]
  const a = actual[fieldName]
  if (d === a) {
    return []
  }
  if ((typeof d) !== "object") {  // is scalar
    console.log({mismatch: true, fieldName: fieldName, desired: d, actual: a});
    return [{ field: fieldName, desired: d, actual: a}];
  }
  if (!Array.isArray(d)) {
    throw "unexpected type";
  }
  if (d.length !== a.length) {
    return [{ field: fieldName + ".length", desired: d.length, actual: a.length}];
  }
  return zip(d, a).filter(([de, ae]) => (de !== ae)).map(([de, ae], i) => {
    return { field: fieldName + "[" + i + "]", desired: de, actual: ae };
  });
}

function deepCopy(src) {
  return JSON.parse(JSON.stringify(src))
}

function constructExpectedStructure(sharedContent, skillAreaTitles) {
  var expectedStructure = deepCopy(sharedContent.topLevelLiterals);
  expectedStructure["items"] = deepCopy(sharedContent.firstItems);
  skillAreaTitles.map((skillAreaTitle, i) => {
    expectedStructure.items[0].choices.push({
      pageNavigationType: "GO_TO_PAGE",
      value: skillAreaTitle,
      gotoPage: { title: skillAreaTitle },
    })

    const nPrefixItems = sharedContent.firstItems.length;
    const nItemsPerSkillArea = sharedContent.itemsPerSkillArea.length;

    var itemsToAdd = JSON.parse(JSON.stringify(sharedContent.itemsPerSkillArea));
    itemsToAdd.map((item,j) => {
      if (item.title) {
        item.title = item.title.replace('SKILL_AREA_TITLE', skillAreaTitle);
      }
      if (item.gotoPage && item.gotoPage.title) {
        item.gotoPage.title = item.gotoPage.title.replace('SKILL_AREA_TITLE', skillAreaTitle);
      }
      item["index"] = nItemsPerSkillArea * i + j + nPrefixItems;
    });
    if (i == 0) {
      itemsToAdd[0].pageNavigationType = "SUBMIT";
      delete(itemsToAdd[0].gotoPage);
    }
    expectedStructure.items.push(...itemsToAdd);
  });
  expectedStructure["items"].push(...(JSON.parse(JSON.stringify(sharedContent.lastItems))));
  return expectedStructure;
}

function extractActualContentFromFormSpec(actualFormSpec) {
  const content = actualFormSpec.items[0].choices.map(c => c.value).map(t => {
    return {
      title: t,
      description: "",
      basicSkills: [],
      advancedSkills: [],
    };
  });
  content.map((sa, index) => {
    const basicIndex = actualFormSpec.items.findIndex(item => item.type == "PAGE_BREAK" && item.title === sa.title);
    const advancedIndex = actualFormSpec.items.findIndex(item => item.type == "PAGE_BREAK" && item.title === "Advanced " + sa.title);

    const basicDescription = actualFormSpec.items[basicIndex].helpText;
    const advancedDescription = actualFormSpec.items[basicIndex].helpText;

    const basicSkills = actualFormSpec.items[basicIndex+2].rows;
    const advancedSkills = actualFormSpec.items[advancedIndex+2].rows;

    content[index].description = basicDescription;
    content[index].basicSkills = basicSkills;
    content[index].advancedSkills = advancedSkills;
  });

  return content;
}


function validateContent(expectedContent, actualContent) {
  return zip(expectedContent, actualContent).map(([desired, actual]) => {
    return {
      title: desired.title,
      mismatches: Object.entries(desired).map(([fieldName, fieldValue]) => detectMismatches(desired, actual, fieldName)).flat()
    };
  }).filter(m => m.mismatches.length > 0); 
}

</script>